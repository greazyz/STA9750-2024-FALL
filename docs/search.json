[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Gracie Zheng",
    "section": "",
    "text": "Enrolled in the MS Statistics program at the Zicklin School of Business, I am graduating in May 2026.\nI currently work at my family restaurant alongside my mom.\nI am ambidextrous; I use chopsticks on my right hand and do everything else with my left hand.\nI am really good at Tetris."
  },
  {
    "objectID": "mp01.html",
    "href": "mp01.html",
    "title": "mp01",
    "section": "",
    "text": "In this mini project, I will be analyzing the fiscal characteristics of public transit systems in the United States through summary statistics and coming to the conclusion of which is the most efficient transit system.\nGiven the data, I am downloading the files and cleaning and joining the fares and expenses tables.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nFARES &lt;- readxl::read_xlsx(\"2022_fare_revenue.xlsx\") |&gt;\n  select(-`State/Parent NTD ID`, \n         -`Reporter Type`,\n         -`Reporting Module`,\n         -`TOS`,\n         -`Passenger Paid Fares`,\n         -`Organization Paid Fares`) |&gt;\n  filter(`Expense Type` == \"Funds Earned During Period\") |&gt;\n  select(-`Expense Type`) |&gt;\n  group_by(`NTD ID`,       \n           `Agency Name`,  \n           `Mode`) |&gt;      \n  summarize(`Total Fares` = sum(`Total Fares`)) |&gt;\n  ungroup()\n\n`summarise()` has grouped output by 'NTD ID', 'Agency Name'. You can override\nusing the `.groups` argument.\n\n# expenses file \n\nEXPENSES &lt;- readr::read_csv(\"2022_expenses.csv\") |&gt;\n  select(`NTD ID`, \n         `Agency`,\n         `Total`, \n         `Mode`) |&gt;\n  mutate(`NTD ID` = as.integer(`NTD ID`)) |&gt;\n  rename(Expenses = Total) |&gt;\n  group_by(`NTD ID`, `Mode`) |&gt;\n  summarize(Expenses = sum(Expenses)) |&gt;\n  ungroup()\n\nRows: 3744 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (10): Agency, City, State, NTD ID, Organization Type, Reporter Type, UZA...\ndbl  (2): Report Year, UACE Code\nnum (10): Primary UZA Population, Agency VOMS, Mode VOMS, Vehicle Operations...\nlgl  (7): Vehicle Operations Questionable, Vehicle Maintenance Questionable,...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n`summarise()` has grouped output by 'NTD ID'. You can override using the `.groups` argument.\n\nFINANCIALS &lt;- inner_join(FARES, EXPENSES, join_by(`NTD ID`, `Mode`))\n\nThe third file is the monthly transit numbers.\n\nlibrary(tidyverse)\nTRIPS &lt;- readxl::read_xlsx(\"ridership.xlsx\", sheet=\"UPT\") |&gt;\n  filter(`Mode/Type of Service Status` == \"Active\") |&gt;\n  select(-`Legacy NTD ID`, \n         -`Reporter Type`, \n         -`Mode/Type of Service Status`, \n         -`UACE CD`, \n         -`TOS`) |&gt;\n  pivot_longer(-c(`NTD ID`:`3 Mode`), \n               names_to=\"month\", \n               values_to=\"UPT\") |&gt;\n  drop_na() |&gt;\n  mutate(month=my(month)) # Parse _m_onth _y_ear date specs\nMILES &lt;- readxl::read_xlsx(\"ridership.xlsx\", sheet=\"VRM\") |&gt;\n  filter(`Mode/Type of Service Status` == \"Active\") |&gt;\n  select(-`Legacy NTD ID`, \n         -`Reporter Type`, \n         -`Mode/Type of Service Status`, \n         -`UACE CD`, \n         -`TOS`) |&gt;\n  pivot_longer(-c(`NTD ID`:`3 Mode`), \n               names_to=\"month\", \n               values_to=\"VRM\") |&gt;\n  drop_na() |&gt;\n  group_by(`NTD ID`, `Agency`, `UZA Name`, \n           `Mode`, `3 Mode`, month) |&gt;\n  summarize(VRM = sum(VRM)) |&gt;\n  ungroup() |&gt;\n  mutate(month=my(month)) # Parse _m_onth _y_ear date specs\n\n`summarise()` has grouped output by 'NTD ID', 'Agency', 'UZA Name', 'Mode', '3\nMode'. You can override using the `.groups` argument.\n\nUSAGE &lt;- inner_join(TRIPS, MILES) |&gt;\n  mutate(`NTD ID` = as.integer(`NTD ID`))\n\nJoining with `by = join_by(`NTD ID`, Agency, `UZA Name`, Mode, `3 Mode`,\nmonth)`\n\n\n\n\n\n\nif(!require(\"DT\")) install.packages(\"DT\")\n\nLoading required package: DT\n\nlibrary(DT)\n\nsample_n(USAGE, 1000) |&gt; \n  mutate(month=as.character(month)) |&gt; \n  DT::datatable()\n\n\n\n\n\n\n\n\nFirst, I am renaming the “UZA Name” column to “metro_area”.\n\nUSAGE &lt;- USAGE |&gt;\n       rename(metro_area = `UZA Name`)\n\n\n\n\n\nunique_modes &lt;- USAGE |&gt; \n  distinct(Mode)\n\nUSAGE &lt;- USAGE |&gt;\n  mutate(Mode=case_when(\n    Mode == \"HR\" ~ \"Heavy Rail\",\n    Mode == \"DR\" ~ \"Demand Response\",\n    Mode == \"FB\" ~ \"Ferryboat\",\n    Mode == \"MB\" ~ \"Bus\",\n    Mode == \"SR\" ~ \"Streetcar Rail\",\n    Mode == \"TB\" ~ \"Trolleybus\",\n    Mode == \"VP\" ~ \"Vanpool\",\n    Mode == \"CB\" ~ \"Commuter Bus\",\n    Mode == \"RB\" ~ \"Bus Rapid Transit\",\n    Mode == \"LR\" ~ \"Light Rail\",\n    Mode == \"YR\" ~ \"Hybrid Rail\",\n    Mode == \"MG\" ~ \"Monorail and Automated Guideway modes\",\n    Mode == \"CR\" ~ \"Commuter Rail\",\n    Mode == \"AR\" ~ \"Alaska Railroad\",\n    Mode == \"TR\" ~ \"Aerial Tramways\",\n    Mode == \"HR\" ~ \"Heavy Rail\",\n    Mode == \"IP\" ~ \"Inclined Plane\",\n    Mode == \"PB\" ~ \"Publico\",\n    Mode == \"CC\" ~ \"Cable Car\",\n    TRUE ~ \"Unknown\"))\n\nThen I reload the table with this code to make it look neater:\n\nif(!require(\"DT\")) install.packages(\"DT\")\nlibrary(DT)\n \ndatatable(\n    sample_n(USAGE, 1000) |&gt;\n      mutate(month = as.character(month)) |&gt;\n      select(-`3 Mode`) |&gt;\n      rename(\n        `Metro Area` = metro_area,\n        `Unlinked Passenger Trips` = UPT,\n        `Vehicle Revenue Miles` = VRM\n      )\n)\n\n\n\n\n\n\n\n\n\nWhat transit agency had the most total VRM in our data set?\n\n\n  most_vrm_agency &lt;- USAGE |&gt;\n  group_by(Agency) |&gt;\n  summarize(total_vrm = sum(VRM, na.rm = TRUE)) |&gt;\n  arrange(desc(total_vrm)) |&gt;\n  slice(1)\nprint (most_vrm_agency)\n\n# A tibble: 1 × 2\n  Agency                      total_vrm\n  &lt;chr&gt;                           &lt;dbl&gt;\n1 MTA New York City Transit 10832855350\n\n\nThe MTA New York City Transit had the most total VRM at 10832855350 miles.\n\nWhat transit mode had the most total VRM in our data set?\n\n\n  most_vrm_mode &lt;- USAGE |&gt;\n  group_by(Mode) |&gt;\n  summarize(total_vrm = sum(VRM, na.rm = TRUE)) |&gt;\n  arrange(desc(total_vrm)) |&gt;\n  slice(1)\nprint (most_vrm_mode)\n\n# A tibble: 1 × 2\n  Mode    total_vrm\n  &lt;chr&gt;       &lt;dbl&gt;\n1 Bus   49444494088\n\n\nBus mode had the most total VRM at 49444494088.\n\nHow many trips were taken on the NYC Subway (Heavy Rail) in May 2024?\n\n\nnyc_subway_trips_may_2024 &lt;- USAGE |&gt;\n  filter(Mode == \"Heavy Rail\", \n         Agency == \"MTA New York City Transit\",\n         month == \"2024-05-01\")\nprint(nyc_subway_trips_may_2024)\n\n# A tibble: 1 × 8\n  `NTD ID` Agency             metro_area Mode  `3 Mode` month         UPT    VRM\n     &lt;int&gt; &lt;chr&gt;              &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;    &lt;date&gt;      &lt;dbl&gt;  &lt;dbl&gt;\n1    20008 MTA New York City… New York-… Heav… Rail     2024-05-01 1.80e8 3.00e7\n\n\n\nHow much did NYC subway ridership fall between April 2019 and April 2020?\n\n\napril_fall &lt;- USAGE |&gt; \n  filter(\n    Mode == \"Heavy Rail\",    # Focus on subway (Heavy Rail)\n    Agency == \"MTA New York City Transit\", \n    month %in% c(\"2019-04-01\", \"2020-04-01\")  # Only April 2019 and April 2020\n  ) |&gt; \n  group_by(month) |&gt;       # Group by month\n  summarize(total_UPT = sum(UPT, na.rm = TRUE)) |&gt;   # Summarize total UPT for each month\n  spread(month, total_UPT) |&gt;   # Spread the month column to calculate difference\n  mutate(april_fall = `2019-04-01` - `2020-04-01`)  # Calculate ridership fall\nprint(april_fall)\n\n# A tibble: 1 × 3\n  `2019-04-01` `2020-04-01` april_fall\n         &lt;dbl&gt;        &lt;dbl&gt;      &lt;dbl&gt;\n1    232223929     20254269  211969660\n\n\n\n\n\n\nWhich 3 Metro Areas have the lowest amount of Vehicle Revenue Miles?\n\n\nleast3_vrm_metro &lt;- USAGE |&gt; \n  group_by(metro_area) |&gt; \n  summarize(total_VRM = sum(VRM, na.rm = TRUE)) |&gt; \n  arrange(total_VRM) |&gt; \n  slice(3)\nprint(least3_vrm_metro)\n\n# A tibble: 1 × 2\n  metro_area        total_VRM\n  &lt;chr&gt;                 &lt;dbl&gt;\n1 Texarkana, TX--AR    262979\n\n\n\nWhich Metro Area Had the Highest Vehicle Revenue Miles (VRM) per Trip?\n\nThis question is aimed to find the metro area that covers the most distance per rider.\n\nvrm_per_trip_metro &lt;- USAGE |&gt; \n  group_by(metro_area) |&gt; \n  summarize(total_VRM = sum(VRM, na.rm = TRUE), \n            total_UPT = sum(UPT, na.rm = TRUE)) |&gt; \n  mutate(vrm_per_trip = total_VRM / total_UPT) |&gt; \n  arrange(desc(vrm_per_trip)) |&gt; \n  slice(1)\nprint(vrm_per_trip_metro)\n\n# A tibble: 1 × 4\n  metro_area     total_VRM total_UPT vrm_per_trip\n  &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n1 Morristown, TN   4386584    261196         16.8\n\n\n\nWhich Agency is busiest in December?\n\n\nbusiest_agency_december &lt;- USAGE |&gt; \n  filter(format(as.Date(month), \"%m\") == \"12\") |&gt;  # Filter for December\n  group_by(Agency) |&gt; \n  summarize(total_UPT = sum(UPT, na.rm = TRUE)) |&gt; \n  arrange(desc(total_UPT)) |&gt; \n  slice(1)\nprint(busiest_agency_december)\n\n# A tibble: 1 × 2\n  Agency                     total_UPT\n  &lt;chr&gt;                          &lt;dbl&gt;\n1 MTA New York City Transit 5630067938\n\n\nI am not sure what I was expecting, but it was not New York. I had a belief that people would go back home to see their family; I forgot about tourism and that the ridership is NYC is extremely high at all times of the year.\n\n\n\n\nusage_2022_annual &lt;- USAGE |&gt;\nfilter(year(month) == \"2022\") |&gt;\n  group_by(\n    `NTD ID`,\n    Agency,\n    metro_area,\n    Mode) |&gt;\n  summarise(\n    Total_VRM = sum(VRM, na.rm = TRUE),\n    Total_UPT = sum(UPT, na.rm = TRUE),\n    .groups = 'drop'\n  ) |&gt;\n  ungroup()\nprint(usage_2022_annual)\n\n# A tibble: 1,141 × 6\n   `NTD ID` Agency                          metro_area Mode  Total_VRM Total_UPT\n      &lt;int&gt; &lt;chr&gt;                           &lt;chr&gt;      &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n 1        1 King County                     Seattle--… Bus    61632644  53983641\n 2        1 King County                     Seattle--… Dema…  12860448    663009\n 3        1 King County                     Seattle--… Ferr…     51236    400407\n 4        1 King County                     Seattle--… Stre…    180369   1117605\n 5        1 King County                     Seattle--… Trol…   2635705   9575043\n 6        1 King County                     Seattle--… Vanp…   4413910    702709\n 7        2 Spokane Transit Authority       Spokane, … Bus     6485325   6595319\n 8        2 Spokane Transit Authority       Spokane, … Dema…   4037502    310316\n 9        2 Spokane Transit Authority       Spokane, … Vanp…    905990     90576\n10        3 Pierce County Transportation B… Seattle--… Bus     4227441   4950296\n# ℹ 1,131 more rows\n\n\nRecall the FINANCIALS table we created in the beginning I am also renaming the modes for financials so it shows in the table.\n\nprint(FINANCIALS)\n\n# A tibble: 1,173 × 5\n   `NTD ID` `Agency Name`                           Mode  `Total Fares` Expenses\n      &lt;dbl&gt; &lt;chr&gt;                                   &lt;chr&gt;         &lt;dbl&gt;    &lt;dbl&gt;\n 1        1 King County Department of Metro Transit CB          5216912   0     \n 2        1 King County Department of Metro Transit DR           832327   6.05e7\n 3        1 King County Department of Metro Transit FB          1715265   8.90e6\n 4        1 King County Department of Metro Transit LR         29386480   0     \n 5        1 King County Department of Metro Transit MB         56846337   6.72e8\n 6        1 King County Department of Metro Transit SR           588495   1.25e7\n 7        1 King County Department of Metro Transit TB         10123486   8.42e7\n 8        1 King County Department of Metro Transit VP          5484481   8.91e6\n 9        2 Spokane Transit Authority               DR           531284   1.80e7\n10        2 Spokane Transit Authority               MB          6135110   7.53e7\n# ℹ 1,163 more rows\n\nFINANCIALS &lt;- FINANCIALS |&gt;\n  mutate(Mode = case_when(\n    Mode == \"HR\" ~ \"Heavy Rail\",\n    Mode == \"DR\" ~ \"Demand Response\",\n    Mode == \"FB\" ~ \"Ferryboat\",\n    Mode == \"MB\" ~ \"Bus\",\n    Mode == \"SR\" ~ \"Streetcar Rail\",\n    Mode == \"TB\" ~ \"Trolleybus\",\n    Mode == \"VP\" ~ \"Vanpool\",\n    Mode == \"CB\" ~ \"Commuter Bus\",\n    Mode == \"RB\" ~ \"Bus Rapid Transit\",\n    Mode == \"LR\" ~ \"Light Rail\",\n    Mode == \"YR\" ~ \"Hybrid Rail\",\n    Mode == \"MG\" ~ \"Monorail and Automated Guideway modes\",\n    Mode == \"CR\" ~ \"Commuter Rail\",\n    Mode == \"AR\" ~ \"Alaska Railroad\",\n    Mode == \"TR\" ~ \"Aerial Tramways\",\n    Mode == \"HR\" ~ \"Heavy Rail\",\n    Mode == \"IP\" ~ \"Inclined Plane\",\n    Mode == \"PB\" ~ \"Publico\",\n    Mode == \"CC\" ~ \"Cable Car\",\n    TRUE ~ \"Unknown\"\n  ))\n\nFollowing this code, the two tables are merged:\n\nUSAGE_AND_FINANCIALS &lt;- left_join(usage_2022_annual, \n           FINANCIALS, \n           join_by(`NTD ID`, Mode)) |&gt;\n    drop_na()\n\nLet’s show the first 1,000!\n\nsample_n(USAGE_AND_FINANCIALS, 1000) \n\n# A tibble: 1,000 × 9\n   `NTD ID` Agency            metro_area Mode  Total_VRM Total_UPT `Agency Name`\n      &lt;dbl&gt; &lt;chr&gt;             &lt;chr&gt;      &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;        \n 1    90196 County of Placer  Sacrament… Comm…      3944      1054 County of Pl…\n 2       44 Skagit Transit    Mount Ver… Dema…    374842     53400 Skagit Trans…\n 3    40035 Central Florida … Orlando, … Dema…   7557232    585706 Central Flor…\n 4    40108 Research Triangl… Durham, NC Dema…    416124     35595 Research Tri…\n 5    20075 Port Authority T… Philadelp… Heav…   4868978   4870310 Port Authori…\n 6    50035 Central County T… Kalamazoo… Dema…    877697    114323 Central Coun…\n 7    90234 Marin County Tra… San Franc… Dema…    421668     49975 Marin County…\n 8    50166 Clermont County,… Cincinnat… Bus      119799     11964 Board of  Cl…\n 9    30202 South Central Tr… Lancaster… Dema…   4415050    313723 South Centra…\n10    50045 Gary Public Tran… Chicago, … Bus      788671    371256 Gary Public …\n# ℹ 990 more rows\n# ℹ 2 more variables: `Total Fares` &lt;dbl&gt;, Expenses &lt;dbl&gt;\n\n\n\n\n\nWhich transit system (agency and mode) had the most UPT in 2022?\n\nmost_upt_2022 &lt;- USAGE_AND_FINANCIALS |&gt;\n     group_by(Agency, Mode) |&gt;\n     filter(sum(Total_UPT, na.rm = TRUE) &gt;= 400000) |&gt;\n     summarise(UPT = sum(Total_UPT),  .groups = 'drop') |&gt;\n     arrange(desc(UPT)) |&gt;\n     slice(1)\nprint(most_upt_2022)\n\n# A tibble: 1 × 3\n  Agency                    Mode              UPT\n  &lt;chr&gt;                     &lt;chr&gt;           &lt;dbl&gt;\n1 MTA New York City Transit Heavy Rail 1793073801\n\n\nThe subway of the MTA New York City Transit system had the most UPT in 2022 at 1,793,073,801.\nWhich transit system (agency and mode) had the highest farebox recovery, defined as the highest ratio of Total Fares to Expenses?\n\nhighest_farebox_recovery &lt;- USAGE_AND_FINANCIALS |&gt;\n  mutate(farebox_recovery = `Total Fares` / Expenses) |&gt;\n  arrange(desc(farebox_recovery)) |&gt;\n  select(-`Agency Name`, -`Total_VRM`, -`Total_UPT`) |&gt; #to be able to see the desired column in my code\n  slice(1)\n\nprint(highest_farebox_recovery)\n\n# A tibble: 1 × 7\n  `NTD ID` Agency       metro_area Mode  `Total Fares` Expenses farebox_recovery\n     &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;         &lt;dbl&gt;    &lt;dbl&gt;            &lt;dbl&gt;\n1    40191 Transit Aut… Elizabeth… Vanp…         97300    40801             2.38\n\n\nIn 2022, vanpooling of the Transit Authority of Central Kentucky had the highest farebox recovery at 2.38.\nWhich transit system (agency and mode) has the lowest expenses per UPT?\n\nlowest_expenses_per_upt &lt;- USAGE_AND_FINANCIALS |&gt;\n  mutate(expenses_per_upt = Expenses / Total_UPT) |&gt;\n  arrange(expenses_per_upt) |&gt;\n  select(-`Agency Name`, -`Total_VRM`, -`Total_UPT`) |&gt; #to be able to see the desired column in my code\n  slice(1)\n\nprint(lowest_expenses_per_upt)\n\n# A tibble: 1 × 7\n  `NTD ID` Agency       metro_area Mode  `Total Fares` Expenses expenses_per_upt\n     &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;         &lt;dbl&gt;    &lt;dbl&gt;            &lt;dbl&gt;\n1    40147 North Carol… Raleigh, … Bus               0  2727412             1.18\n\n\nThe transit system with the lowest expenses per UPT is the North Carolina State University bus with expenses per UPT at $1.18.\nWhich transit system (agency and mode) has the highest total fares per UPT?\n\nhighest_fares_per_upt &lt;- USAGE_AND_FINANCIALS |&gt;\n  mutate(fares_per_upt = `Total Fares` / Total_UPT) |&gt;\n  arrange(desc(fares_per_upt)) |&gt;\n  select(-`Agency Name`, -`Total_VRM`, -`Total_UPT`) |&gt; #to be able to see the desired column in my code\n  slice(1)\n\nprint(highest_fares_per_upt)\n\n# A tibble: 1 × 7\n  `NTD ID` Agency          metro_area Mode  `Total Fares` Expenses fares_per_upt\n     &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;      &lt;chr&gt;         &lt;dbl&gt;    &lt;dbl&gt;         &lt;dbl&gt;\n1    30011 Altoona Metro … Altoona, … Dema…         17163    90550          660.\n\n\nIn 2022, the highest total fares per UPT is at the Altoona Metro Transit by Demand Response.\nWhich transit system (agency and mode) has the lowest expenses per VRM?\n\nlowest_expenses_per_vrm &lt;- USAGE_AND_FINANCIALS |&gt;\n  mutate(expenses_per_vrm = Expenses / Total_VRM) |&gt;\n  arrange(expenses_per_vrm) |&gt;\n  select(-`Agency Name`, -`Total_VRM`, -`Total_UPT`) |&gt; #to be able to see the desired column in my code\n  slice(1)\n\nprint(lowest_expenses_per_vrm)\n\n# A tibble: 1 × 7\n  `NTD ID` Agency       metro_area Mode  `Total Fares` Expenses expenses_per_vrm\n     &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;         &lt;dbl&gt;    &lt;dbl&gt;            &lt;dbl&gt;\n1    66339 New Mexico … Las Cruce… Vanp…        757574   588830            0.337\n\n\nNew Mexico Department of Transportation’s vanpooling system has the lowest expenses per VRM at 0.337.\nWhich transit system (agency and mode) has the highest total fares per VRM?\n\nhighest_fares_per_vrm &lt;- USAGE_AND_FINANCIALS |&gt;\n  mutate(fares_per_vrm = `Total Fares` / Total_VRM) |&gt;\n  arrange(desc(fares_per_vrm)) |&gt;\n  select(-`Agency Name`, -`Total_VRM`, -`Total_UPT`) |&gt; #to be able to see the desired column in my code\n  slice(1)\n\nprint(highest_fares_per_vrm)\n\n# A tibble: 1 × 7\n  `NTD ID` Agency          metro_area Mode  `Total Fares` Expenses fares_per_vrm\n     &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;      &lt;chr&gt;         &lt;dbl&gt;    &lt;dbl&gt;         &lt;dbl&gt;\n1    50521 Chicago Water … Chicago, … Ferr…        142473   211296          237.\n\n\nAt $237, the Chicago Water Taxi’s ferry has the highest total fares per VRM.\n\n\n\nThe most efficient transit system would be the MTA New York Transit System as it moves the most amount of passengers from one destination to another. I am viewing the term “efficiency” as being able to serve the most amount of people with its given size."
  },
  {
    "objectID": "mp01.html#conclusion",
    "href": "mp01.html#conclusion",
    "title": "mp01",
    "section": "",
    "text": "The most efficient transit system would be the MTA New York Transit System as it moves the most amount of passengers from one destination to another. I am viewing the term “efficiency” as being able to serve the most amount of people with its given size."
  },
  {
    "objectID": "mp02.html",
    "href": "mp02.html",
    "title": "Mp02",
    "section": "",
    "text": "As a Hollywood development director, I am always looking into the next BIG thing. To make the biggest movie of 2025 and be invited to Cannes Film Festival, I will dive into the data of movies to find the perfect opportunity.\n\n\nCredits to IMDb, with their expansive library of movies, I will use their datasets for my research. The code to extract the data is as follows:\n\n##loading the data files\nget_imdb_file &lt;- function(fname) {\n  BASE_URL &lt;- \"https://github.com/michaelweylandt/STA9750/raw/main/miniprojects/mini02_preprocessed/\"\n  fname_ext &lt;- paste0(fname, \".csv.zip\")\n  \n  if (!file.exists(fname_ext)) {\n    FILE_URL &lt;- paste0(BASE_URL, fname_ext)\n    download.file(FILE_URL, destfile = fname_ext)\n  }\n  \n  # Unzip the file and read the CSV\n  temp_file &lt;- unzip(fname_ext, list = TRUE)$Name[1]  # Get the name of the first file inside the ZIP\n  unzip(fname_ext)  # Unzip the file\n  as.data.frame(readr::read_csv(temp_file)) \n}\n\nNAME_BASICS     &lt;- get_imdb_file(\"name_basics_small\")\n\nRows: 2460608 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (6): nconst, primaryName, birthYear, deathYear, primaryProfession, known...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nTITLE_BASICS     &lt;- get_imdb_file(\"title_basics_small\")\n\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat &lt;- vroom(...)\n  problems(dat)\n\n\nRows: 372198 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (7): tconst, titleType, primaryTitle, originalTitle, endYear, runtimeMin...\ndbl (2): isAdult, startYear\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nTITLE_EPISODES   &lt;- get_imdb_file(\"title_episodes_small\")\n\nRows: 3007178 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): tconst, parentTconst, seasonNumber, episodeNumber\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nTITLE_RATINGS    &lt;- get_imdb_file(\"title_ratings_small\")\n\nRows: 372198 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): tconst\ndbl (2): averageRating, numVotes\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nTITLE_CREW       &lt;- get_imdb_file(\"title_crew_small\")\n\nRows: 371902 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): tconst, directors, writers\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nTITLE_PRINCIPALS &lt;- get_imdb_file(\"title_principals_small\") \n\nRows: 6586689 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): tconst, nconst, category, job, characters\ndbl (1): ordering\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\n\nWith such a huge dataset, I narrow down to people with at least 2 “known for” credits.\n\n# make sure to run this\nlibrary(stringr)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nNAME_BASICS &lt;- NAME_BASICS |&gt; \n    filter(str_count(knownForTitles, \",\") &gt; 1)\n\nThen I narrow down titles through rating count. Pictured below is a visualization of the distribution of rating counts across the titles:\n\n#make sure to\n#load \nlibrary(ggplot2)\n\nTITLE_RATINGS |&gt;\n    ggplot(aes(x=numVotes)) + \n    geom_histogram(bins=30) +\n    xlab(\"Number of IMDB Ratings\") + \n    ylab(\"Number of Titles\") + \n    ggtitle(\"Majority of IMDB Titles Have Less than 100 Ratings\") + \n    theme_bw() + \n    scale_x_log10(label = scales::comma) + \n    scale_y_continuous(label = scales::comma)\n\n\n\n\n\n\n\nprint(ggplot)\n\nfunction (data = NULL, mapping = aes(), ..., environment = parent.frame()) \n{\n    UseMethod(\"ggplot\")\n}\n&lt;bytecode: 0x000002e20744cc30&gt;\n&lt;environment: namespace:ggplot2&gt;\n\n\nAbout 75% of the dataset is has less than 100 ratings and we can see this through quantile distribution:\n\n#load library(dplyr) for function \"pull\"\nlibrary(dplyr)\nTITLE_RATINGS |&gt;\n    pull(numVotes) |&gt;\n    quantile()\n\n     0%     25%     50%     75%    100% \n    100     165     332     970 2942823 \n\n\nThrough this step, I filter the data to only view titles with 100 or more ratings:\n\nTITLE_RATINGS &lt;- TITLE_RATINGS |&gt;\n    filter(numVotes &gt;= 100)\n\nThis filtering is then applied to the rest of the data tables:\n\nTITLE_BASICS &lt;- TITLE_BASICS |&gt;\n    semi_join(TITLE_RATINGS, \n              join_by(tconst == tconst))\n\nTITLE_CREW &lt;- TITLE_CREW |&gt;\n    semi_join(TITLE_RATINGS, \n              join_by(tconst == tconst))\n\nTITLE_EPISODES_1 &lt;- TITLE_EPISODES |&gt;\n    semi_join(TITLE_RATINGS, \n              join_by(tconst == tconst))\nTITLE_EPISODES_2 &lt;- TITLE_EPISODES |&gt;\n    semi_join(TITLE_RATINGS, \n              join_by(parentTconst == tconst))\n\nTITLE_EPISODES &lt;- bind_rows(TITLE_EPISODES_1,\n                            TITLE_EPISODES_2) |&gt;\n    distinct()\n\nTITLE_PRINCIPALS &lt;- TITLE_PRINCIPALS |&gt;\n    semi_join(TITLE_RATINGS, join_by(tconst == tconst))\n\n\nrm(TITLE_EPISODES_1)\nrm(TITLE_EPISODES_2)\n\nFrom the IMDb site, I see that columns that should be set as numeric type are set as character (string) vectors. I change this by using the following command:\n\n# Load dplyr library\nlibrary(dplyr)\n\nNAME_BASICS &lt;- NAME_BASICS |&gt;\n    mutate(birthYear = as.numeric(birthYear),\n           deathYear = as.numeric(deathYear))\n\nWarning: There were 2 warnings in `mutate()`.\nThe first warning was:\nℹ In argument: `birthYear = as.numeric(birthYear)`.\nCaused by warning:\n! NAs introduced by coercion\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n\n\n\nIn Task 1, I will correct the column types of applicable tables, just like with the NAME_BASICS table.\n\nTITLE_BASICS &lt;- TITLE_BASICS |&gt;\n  mutate(\n    isAdult = as.logical(isAdult),\n    startYear = as.numeric(startYear),    # Coerce\n    endYear = as.numeric(endYear), # Coerce \n    runtimeMinutes = as.numeric(runtimeMinutes)\n  )\n\nWarning: There were 2 warnings in `mutate()`.\nThe first warning was:\nℹ In argument: `endYear = as.numeric(endYear)`.\nCaused by warning:\n! NAs introduced by coercion\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\nTITLE_EPISODES &lt;- TITLE_EPISODES |&gt;\n  mutate(seasonNumber = as.numeric(seasonNumber),\n         episodeNumber = as.numeric(episodeNumber))\n\nWarning: There were 2 warnings in `mutate()`.\nThe first warning was:\nℹ In argument: `seasonNumber = as.numeric(seasonNumber)`.\nCaused by warning:\n! NAs introduced by coercion\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\nTITLE_RATINGS &lt;- TITLE_RATINGS |&gt;\n  mutate(\n    averageRating = as.numeric(averageRating),    # Coerce\n    numVotes = as.numeric(numVotes )     # Coerce \n  )\n\nLooking through the IMDb dataset details on the site, I found that only TITLE_BASICS and TITLE_RATINGS needed to be corrected.\n\n\n\nUsing dplyr functionality, I will answer these questions:\n\n\n\n# Load necessary libraries\nlibrary(dplyr)\n\n# Count the number\nTITLE_movie &lt;- TITLE_BASICS |&gt;\n  filter(titleType == \"movie\") |&gt;\n  summarise(count = n())\n\nTITLE_tvseries &lt;- TITLE_BASICS |&gt;\n  filter(titleType == \"tvSeries\") |&gt;\n  summarise(count = n())\n\nTITLE_tvepisode &lt;- TITLE_BASICS |&gt;\n  filter(titleType == \"tvEpisode\") |&gt;\n  summarise(count = n())\n\n# Print the result\nprint(TITLE_movie)\n\n   count\n1 131662\n\nprint(TITLE_tvseries)\n\n  count\n1 29789\n\nprint(TITLE_tvepisode)\n\n   count\n1 155722\n\n\nFrom the filtered datasets, there are 132,220 movies, 29,986 TV series, and 156,725 TV episodes.\n\n\n\n\n# Load necessary libraries\nlibrary(dplyr)\n\n# Filter for living people (i.e., no deathYear) and select the oldest one by birth year\noldest_living_p &lt;- NAME_BASICS |&gt;\n  filter(is.na(deathYear) & !is.na(birthYear)) |&gt;  # Only living people with known birthYear\n  arrange(birthYear) |&gt;                             # Sort by birth year (ascending)\n  slice(1)                                           # Select the first (oldest) person\n\n# Print the result\nprint(oldest_living_p |&gt; select(primaryName, birthYear ))\n\n      primaryName birthYear\n1 Robert De Visée      1655\n\n\nThe oldest living person is Traudl Lessing, based on the data table. However, I know that is most definitely not true because she was born in 1625. When I check the IMDb site of Traudl Lessing, I see that it is missing her death date. I will change show the top 20 oldest people. Someone must have entered data incorrectly. This really shows the importance of inputting data.\n\n# Load necessary libraries\nlibrary(dplyr)\n\n# Filter for living people (i.e., no deathYear) and select the oldest one by birth year\noldest_living_p &lt;- NAME_BASICS |&gt;\n  filter(is.na(deathYear) & !is.na(birthYear)) |&gt;  # Only living people with known birthYear\n  arrange(birthYear) |&gt;                             # Sort by birth year (ascending)\n  head(20)                                         # Select the top 3 (oldest) person\n\n# Print the result\nprint(oldest_living_p |&gt; select(primaryName, birthYear ))\n\n         primaryName birthYear\n1    Robert De Visée      1655\n2     William Sandys      1767\n3     Richard Dybeck      1811\n4     Albert Monnier      1815\n5         C. Hostrup      1818\n6     Edouard Martin      1825\n7      Ion Ivanovici      1845\n8    Attilio Corbell      1850\n9      André Sylvane      1850\n10    Charles Dungan      1853\n11      Jacob Abrams      1854\n12   James W. Castle      1854\n13   Edmond Duquesne      1854\n14 Maurice Ordonneau      1854\n15      Adolf Weisse      1855\n16   Black Dyke Band      1855\n17     William Parry      1856\n18 Arthur Weinschenk      1856\n19    Emile La Croix      1857\n20    Robert Charvay      1858\n\n\nUnfortunately, the top 20 “oldest living” people based on the dataset of NAME_BASICS are all incorrect. To answer the question simply based on the data, it would be Traudl Lessing but I would need the deathYear inputted to all celebrities in order to answer the question.\n\n\n\n\nlibrary(dplyr)\n\n# Filter the ratings dataset for titles with a perfect 10/10 rating and at least 200,000 votes\nperfect_episodes &lt;- TITLE_RATINGS |&gt;\n  filter(averageRating == 10, numVotes &gt;= 200000)\n\n# Join with the basics data to get more information about TV episodes\nperfect_tv_episode &lt;- perfect_episodes |&gt;\n  inner_join(TITLE_BASICS, by = \"tconst\") |&gt;\n  filter(titleType == \"tvEpisode\")\n\n# Join with the episode dataset to find the series name\nperfect_tv_episode_show &lt;- perfect_tv_episode |&gt;\n  left_join(TITLE_EPISODES, by = \"tconst\") |&gt;\n  left_join(TITLE_BASICS, by = join_by(parentTconst == tconst), suffix = c(\"_episode\", \"_series\"))\n\n# Print the episode title and its parent series title\nperfect_tv_episode_show |&gt;\n  select(primaryTitle_episode, primaryTitle_series) |&gt;\n  print()\n\n  primaryTitle_episode primaryTitle_series\n1           Ozymandias        Breaking Bad\n\n\nIt is episode Ozymandias from Breaking Bad.\n\n\n\n\n# Find Mark Hamill's entry using his name and extract his 'knownForTitles'\nmark_hamill &lt;- NAME_BASICS|&gt;\n  filter(primaryName == \"Mark Hamill\") |&gt;\n  select(nconst, knownForTitles)\n\n# Split the knownForTitles (which is a comma-separated string) into individual tconsts\nknown_titles &lt;- unlist(strsplit(mark_hamill$knownForTitles, \",\"))\n\n# Filter the title.basics data to get information about Mark Hamill's \"known for\" titles\nmark_hamill_known_for &lt;- TITLE_BASICS|&gt;\n  filter(tconst %in% known_titles) |&gt;\n  select(primaryTitle, titleType)\n\n# Print the result\nprint(mark_hamill_known_for)\n\n                                    primaryTitle titleType\n1             Star Wars: Episode IV - A New Hope     movie\n2 Star Wars: Episode V - The Empire Strikes Back     movie\n3     Star Wars: Episode VI - Return of the Jedi     movie\n4        Star Wars: Episode VIII - The Last Jedi     movie\n\n\nMark Hamill is most known for his roles in Star Wars!\n\n\n\n\n# Filter for TV episodes and join with episode details (parentTconst)\ntv_episodes &lt;- TITLE_EPISODES|&gt;\n  inner_join(TITLE_BASICS, by = c(\"tconst\" = \"tconst\")) |&gt;\n  filter(titleType == \"tvEpisode\") |&gt;\n  select(tconst, parentTconst)\n\n# Count the number of episodes per series\nseries_episode_counts &lt;- tv_episodes|&gt;\n  group_by(parentTconst) |&gt;\n  summarise(episode_count = n()) |&gt;\n  filter(episode_count &gt; 12)  # Filter for series with more than 12 episodes\n\n# Calculate the average rating for each series based on episode ratings\nseries_avg_rating &lt;- tv_episodes|&gt;\n  inner_join(TITLE_RATINGS, by = \"tconst\") |&gt;\n  inner_join(series_episode_counts, by = \"parentTconst\") |&gt;\n  group_by(parentTconst) |&gt;\n  summarise(average_series_rating = mean(averageRating, na.rm = TRUE))|&gt;\n  arrange(desc(average_series_rating))  # Sort by highest average rating\n\n# Join with the basics dataset to get series titles\ntop_rated_series &lt;- series_avg_rating|&gt;\n  inner_join(TITLE_BASICS, by = c(\"parentTconst\" = \"tconst\")) |&gt;\n  select(primaryTitle, average_series_rating) |&gt;\n  slice(1)  # Get the series with the highest average rating\n\n# Print the result\nprint(top_rated_series)\n\n# A tibble: 1 × 2\n  primaryTitle                 average_series_rating\n  &lt;chr&gt;                                        &lt;dbl&gt;\n1 Kavya - Ek Jazbaa, Ek Junoon                  9.75\n\n\nThe Kayva TV series has the highest average rating of 9.75.\n\n\n\n\nlibrary(dplyr)\n\n# Find the tconst for Happy Days\nhappy_days_series &lt;- TITLE_BASICS |&gt;\n  filter(primaryTitle == \"Happy Days\" & titleType == \"tvSeries\") |&gt;\n  select(tconst)\n\n# Filter for Happy Days episodes from title_episode\nhappy_days_episodes &lt;- TITLE_EPISODES |&gt;\n  filter(parentTconst == happy_days_series$tconst)  |&gt;\n  select(tconst, seasonNumber, episodeNumber)\n\nI have selected the columns I am looking at. I will put it into a visualization to answer the questions.\n\nlibrary(ggplot2)\n\n# Join with ratings data to get episode ratings\nhappy_days_ratings &lt;- happy_days_episodes |&gt;\n  inner_join(TITLE_RATINGS, by = \"tconst\")  |&gt;\n  filter(!is.na(seasonNumber))  # Exclude episodes without season information\n\n# Define early seasons (1-5) and later seasons (6 and beyond)\nhappy_days_ratings &lt;- happy_days_ratings |&gt;\n  mutate(season_group = ifelse(seasonNumber &lt;= 5, \"Early Seasons (1-5)\", \"Later Seasons (6+)\"))\n\n# Calculate the average rating for early and later seasons\nseason_group_avg &lt;- happy_days_ratings |&gt;\n  group_by(season_group) |&gt;\n  summarise(average_rating = mean(averageRating, na.rm = TRUE),\n            episode_count = n())\n\n# Print the average ratings for early and later seasons\nprint(season_group_avg)\n\n# A tibble: 2 × 3\n  season_group        average_rating episode_count\n  &lt;chr&gt;                        &lt;dbl&gt;         &lt;int&gt;\n1 Early Seasons (1-5)           7.53            58\n2 Later Seasons (6+)            6.83            10\n\n# Plot average ratings of early vs later seasons\nggplot(season_group_avg, aes(x = season_group, y = average_rating, fill = season_group)) +\n  geom_bar(stat = \"identity\") +\n  labs(title = \"Average Ratings: Early vs Later Seasons of Happy Days\",\n       x = \"Season Group\",\n       y = \"Average Rating\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\nBased on the histogram, yes, it is true that the ratings of Happy Days got lower as the show progressed.\n\n\n\n\n\nA “success” measure that reflects both quality and popular awareness will include average ratings and number of votes. A common approach is to compute a weighted score of both of these factors so it looks like success = averageRating x log(numVotes)\n\n\n\n# Load necessary libraries\nlibrary(dplyr)\n\n# Create a success metric\nmetric &lt;- TITLE_RATINGS |&gt;\n  mutate(success_metric = averageRating * log(numVotes))\n\ntop_movies &lt;- metric |&gt;\n  arrange(desc(success_metric))  |&gt;\n  slice(1:10)  # Select the top 10 movies based on the success metric\n\n# Join with the basics dataset to get movie titles for validation\ntop_movies_with_titles &lt;- top_movies |&gt;\n  inner_join(TITLE_BASICS, by = \"tconst\")  |&gt;\n  select(primaryTitle, averageRating, numVotes, success_metric)  # Display relevant info\n\n# Print the top movies with titles and success metric\nprint(top_movies_with_titles)\n\n                                        primaryTitle averageRating numVotes\n1                                       Breaking Bad           9.5  2208030\n2                           The Shawshank Redemption           9.3  2942823\n3                                    Game of Thrones           9.2  2346428\n4                                    The Dark Knight           9.0  2922922\n5                                      The Godfather           9.2  2051186\n6      The Lord of the Rings: The Return of the King           9.0  2013824\n7                                       Pulp Fiction           8.9  2260017\n8                                          Inception           8.8  2595555\n9  The Lord of the Rings: The Fellowship of the Ring           8.9  2043202\n10                                        Fight Club           8.8  2374722\n   success_metric\n1        138.7723\n2        138.5224\n3        134.9493\n4        133.9928\n5        133.7121\n6        130.6399\n7        130.2149\n8        129.9699\n9        129.3173\n10       129.1874\n\n\n\n\n\n\n# Load necessary libraries\nlibrary(dplyr)\n\n# Create the success metric as before\nmetric &lt;- TITLE_RATINGS |&gt;\n  mutate(success_metric = averageRating * log(numVotes + 1))  # Add 1 to avoid log(0)\n\n# Filter for movies with large numbers of votes and low success metric. Assuming 'large' is more than 100,000 votes\nlow_success_movies &lt;- metric |&gt;\n  filter(numVotes &gt; 100000)  |&gt;\n  arrange(success_metric)  |&gt;\n  slice(1:5)  # Select the bottom 5 movies with poor success metric\n\n# Join with title.basics to get the titles for validation\nlow_success_movies_with_titles &lt;- low_success_movies %&gt;%\n  inner_join(TITLE_BASICS, by = \"tconst\") %&gt;%\n  select(primaryTitle, averageRating, numVotes, success_metric)  # Display relevant info\n\n# Print the bottom 5 movies with titles and metrics\nprint(low_success_movies_with_titles)\n\n       primaryTitle averageRating numVotes success_metric\n1             Radhe           1.9   180205       22.99353\n2        Epic Movie           2.4   110222       27.86463\n3         Adipurush           2.7   133981       31.87474\n4 Meet the Spartans           2.8   112199       32.55851\n5          365 Days           3.3   100579       38.01174\n\n\n\n\n\nTHe last movie I went to see in theaters was CHristopher Nolan’s Oppenheimer. I will pick him as a prestige director for this example.\n\n# Load necessary libraries\nlibrary(dplyr)\n\n# Find the nconst for Christopher Nolan\nnolan &lt;- NAME_BASICS %&gt;%\n  filter(primaryName == \"Christopher Nolan\") %&gt;%\n  select(nconst)\n\n# Find all projects where Christopher Nolan is the director\nnolan_projects &lt;- TITLE_PRINCIPALS %&gt;%\n  filter(nconst == nolan$nconst, category == \"director\") %&gt;%\n  select(tconst)\n\nI found Christopher Nolan within the Name table and Principals title. Now I will join them the success metric in the ratings table then join with title_basic to get project titles.\n\n# Join Nolan's projects with the ratings data to calculate success metrics\nnolan_projects_ratings &lt;- nolan_projects %&gt;%\n  inner_join(TITLE_RATINGS, by = \"tconst\") %&gt;%\n  mutate(success_metric = averageRating * log(numVotes + 1))  # Success metric\n\n# Step 4: Join with the basics dataset to get project titles\nnolan_projects_with_titles &lt;- nolan_projects_ratings %&gt;%\n  inner_join(TITLE_BASICS, by = \"tconst\") %&gt;%\n  select(primaryTitle, averageRating, numVotes, success_metric) %&gt;%\n  arrange(desc(success_metric))  # Sort by highest success metric\n\n# Step 5: Print top projects by success metric for Christopher Nolan\nprint(nolan_projects_with_titles)\n\n      primaryTitle averageRating numVotes success_metric\n1  The Dark Knight           9.0  2922922      133.99285\n2        Inception           8.8  2595555      129.96994\n3     Interstellar           8.7  2161548      126.90112\n4    Batman Begins           8.2  1603362      117.15843\n5      Oppenheimer           8.3   797550      112.79120\n6          Dunkirk           7.8   752538      105.54342\n7            Tenet           7.3   606902       97.20771\n8         Insomnia           7.2   323258       91.34071\n9        Following           7.4   103363       85.44049\n10            Quay           6.4     1740       47.75818\n\n\n\n\n\nOne more “spot check” can be to see if Oscar-winning movies have a high success score. I looked up some movies to manually input into the code to check.\n\n# Load necessary libraries\nlibrary(dplyr)\n\n# List of famous Oscar-winning movies (Best Picture winners)\noscar_winners &lt;- c(\"The Godfather\", \"Schindler's List\", \"The Silence of the Lambs\", \n                   \"Forrest Gump\", \"Gladiator\", \"No Country for Old Men\", \"Parasite\")\n\n# Filter the IMDb basics dataset to find tconsts of these movies\noscar_winner_movies &lt;- TITLE_BASICS %&gt;%\n  filter(primaryTitle %in% oscar_winners) %&gt;%\n  select(tconst, primaryTitle)\n\n# Step 3: Join with the ratings data to get the success metric for these movies\noscar_winner_ratings &lt;- oscar_winner_movies %&gt;%\n  inner_join(TITLE_RATINGS, by = \"tconst\") %&gt;%\n  mutate(success_metric = averageRating * log(numVotes + 1))  # Success metric\n\n# Step 4: Display the results to validate if these Oscar-winning movies score highly\noscar_winner_ratings %&gt;%\n  select(primaryTitle, averageRating, numVotes, success_metric) %&gt;%\n  arrange(desc(success_metric)) %&gt;%\n  print()\n\n               primaryTitle averageRating numVotes success_metric\n1             The Godfather           9.2  2051186      133.71215\n2              Forrest Gump           8.8  2301630      128.91233\n3          Schindler's List           9.0  1475891      127.84296\n4  The Silence of the Lambs           8.6  1578087      122.73683\n5                 Gladiator           8.5  1658228      121.73072\n6                  Parasite           8.5   993790      117.37890\n7    No Country for Old Men           8.2  1082550      113.93761\n8             The Godfather           8.3     4072       68.99072\n9                 Gladiator           6.5    10651       60.27777\n10                 Parasite           7.4     1869       55.74933\n11            The Godfather           8.3      679       54.13337\n12             Forrest Gump           7.8      540       49.08867\n13                 Parasite           8.5      298       48.45377\n14                Gladiator           7.8      323       45.08980\n15                Gladiator           7.1      449       43.37566\n16            The Godfather           8.8      106       41.12089\n17            The Godfather           7.9      127       38.33104\n18                 Parasite           5.0     1543       36.71066\n19            The Godfather           7.7      100       35.53643\n20             Forrest Gump           7.6      100       35.07492\n21   No Country for Old Men           7.2      101       33.29980\n22                 Parasite           4.1     3143       33.01833\n23            The Godfather           6.5      145       32.39344\n24            The Godfather           5.3      444       32.31979\n25            The Godfather           5.9      216       31.74139\n26                 Parasite           4.9      399       29.35818\n27                 Parasite           2.8      698       18.33902"
  },
  {
    "objectID": "mp02.html#datasets-for-research",
    "href": "mp02.html#datasets-for-research",
    "title": "Mp02",
    "section": "",
    "text": "Credits to IMDb, with their expansive library of movies, I will use their datasets for my research. The code to extract the data is as follows:\n\n##loading the data files\nget_imdb_file &lt;- function(fname) {\n  BASE_URL &lt;- \"https://github.com/michaelweylandt/STA9750/raw/main/miniprojects/mini02_preprocessed/\"\n  fname_ext &lt;- paste0(fname, \".csv.zip\")\n  \n  if (!file.exists(fname_ext)) {\n    FILE_URL &lt;- paste0(BASE_URL, fname_ext)\n    download.file(FILE_URL, destfile = fname_ext)\n  }\n  \n  # Unzip the file and read the CSV\n  temp_file &lt;- unzip(fname_ext, list = TRUE)$Name[1]  # Get the name of the first file inside the ZIP\n  unzip(fname_ext)  # Unzip the file\n  as.data.frame(readr::read_csv(temp_file)) \n}\n\nNAME_BASICS     &lt;- get_imdb_file(\"name_basics_small\")\n\nRows: 2460608 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (6): nconst, primaryName, birthYear, deathYear, primaryProfession, known...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nTITLE_BASICS     &lt;- get_imdb_file(\"title_basics_small\")\n\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat &lt;- vroom(...)\n  problems(dat)\n\n\nRows: 372198 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (7): tconst, titleType, primaryTitle, originalTitle, endYear, runtimeMin...\ndbl (2): isAdult, startYear\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nTITLE_EPISODES   &lt;- get_imdb_file(\"title_episodes_small\")\n\nRows: 3007178 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): tconst, parentTconst, seasonNumber, episodeNumber\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nTITLE_RATINGS    &lt;- get_imdb_file(\"title_ratings_small\")\n\nRows: 372198 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): tconst\ndbl (2): averageRating, numVotes\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nTITLE_CREW       &lt;- get_imdb_file(\"title_crew_small\")\n\nRows: 371902 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): tconst, directors, writers\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nTITLE_PRINCIPALS &lt;- get_imdb_file(\"title_principals_small\") \n\nRows: 6586689 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): tconst, nconst, category, job, characters\ndbl (1): ordering\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "mp02.html#data-sub-sampling",
    "href": "mp02.html#data-sub-sampling",
    "title": "Mp02",
    "section": "",
    "text": "With such a huge dataset, I narrow down to people with at least 2 “known for” credits.\n\n# make sure to run this\nlibrary(stringr)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nNAME_BASICS &lt;- NAME_BASICS |&gt; \n    filter(str_count(knownForTitles, \",\") &gt; 1)\n\nThen I narrow down titles through rating count. Pictured below is a visualization of the distribution of rating counts across the titles:\n\n#make sure to\n#load \nlibrary(ggplot2)\n\nTITLE_RATINGS |&gt;\n    ggplot(aes(x=numVotes)) + \n    geom_histogram(bins=30) +\n    xlab(\"Number of IMDB Ratings\") + \n    ylab(\"Number of Titles\") + \n    ggtitle(\"Majority of IMDB Titles Have Less than 100 Ratings\") + \n    theme_bw() + \n    scale_x_log10(label = scales::comma) + \n    scale_y_continuous(label = scales::comma)\n\n\n\n\n\n\n\nprint(ggplot)\n\nfunction (data = NULL, mapping = aes(), ..., environment = parent.frame()) \n{\n    UseMethod(\"ggplot\")\n}\n&lt;bytecode: 0x000002e20744cc30&gt;\n&lt;environment: namespace:ggplot2&gt;\n\n\nAbout 75% of the dataset is has less than 100 ratings and we can see this through quantile distribution:\n\n#load library(dplyr) for function \"pull\"\nlibrary(dplyr)\nTITLE_RATINGS |&gt;\n    pull(numVotes) |&gt;\n    quantile()\n\n     0%     25%     50%     75%    100% \n    100     165     332     970 2942823 \n\n\nThrough this step, I filter the data to only view titles with 100 or more ratings:\n\nTITLE_RATINGS &lt;- TITLE_RATINGS |&gt;\n    filter(numVotes &gt;= 100)\n\nThis filtering is then applied to the rest of the data tables:\n\nTITLE_BASICS &lt;- TITLE_BASICS |&gt;\n    semi_join(TITLE_RATINGS, \n              join_by(tconst == tconst))\n\nTITLE_CREW &lt;- TITLE_CREW |&gt;\n    semi_join(TITLE_RATINGS, \n              join_by(tconst == tconst))\n\nTITLE_EPISODES_1 &lt;- TITLE_EPISODES |&gt;\n    semi_join(TITLE_RATINGS, \n              join_by(tconst == tconst))\nTITLE_EPISODES_2 &lt;- TITLE_EPISODES |&gt;\n    semi_join(TITLE_RATINGS, \n              join_by(parentTconst == tconst))\n\nTITLE_EPISODES &lt;- bind_rows(TITLE_EPISODES_1,\n                            TITLE_EPISODES_2) |&gt;\n    distinct()\n\nTITLE_PRINCIPALS &lt;- TITLE_PRINCIPALS |&gt;\n    semi_join(TITLE_RATINGS, join_by(tconst == tconst))\n\n\nrm(TITLE_EPISODES_1)\nrm(TITLE_EPISODES_2)\n\nFrom the IMDb site, I see that columns that should be set as numeric type are set as character (string) vectors. I change this by using the following command:\n\n# Load dplyr library\nlibrary(dplyr)\n\nNAME_BASICS &lt;- NAME_BASICS |&gt;\n    mutate(birthYear = as.numeric(birthYear),\n           deathYear = as.numeric(deathYear))\n\nWarning: There were 2 warnings in `mutate()`.\nThe first warning was:\nℹ In argument: `birthYear = as.numeric(birthYear)`.\nCaused by warning:\n! NAs introduced by coercion\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n\n\n\nIn Task 1, I will correct the column types of applicable tables, just like with the NAME_BASICS table.\n\nTITLE_BASICS &lt;- TITLE_BASICS |&gt;\n  mutate(\n    isAdult = as.logical(isAdult),\n    startYear = as.numeric(startYear),    # Coerce\n    endYear = as.numeric(endYear), # Coerce \n    runtimeMinutes = as.numeric(runtimeMinutes)\n  )\n\nWarning: There were 2 warnings in `mutate()`.\nThe first warning was:\nℹ In argument: `endYear = as.numeric(endYear)`.\nCaused by warning:\n! NAs introduced by coercion\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\nTITLE_EPISODES &lt;- TITLE_EPISODES |&gt;\n  mutate(seasonNumber = as.numeric(seasonNumber),\n         episodeNumber = as.numeric(episodeNumber))\n\nWarning: There were 2 warnings in `mutate()`.\nThe first warning was:\nℹ In argument: `seasonNumber = as.numeric(seasonNumber)`.\nCaused by warning:\n! NAs introduced by coercion\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\nTITLE_RATINGS &lt;- TITLE_RATINGS |&gt;\n  mutate(\n    averageRating = as.numeric(averageRating),    # Coerce\n    numVotes = as.numeric(numVotes )     # Coerce \n  )\n\nLooking through the IMDb dataset details on the site, I found that only TITLE_BASICS and TITLE_RATINGS needed to be corrected.\n\n\n\nUsing dplyr functionality, I will answer these questions:\n\n\n\n# Load necessary libraries\nlibrary(dplyr)\n\n# Count the number\nTITLE_movie &lt;- TITLE_BASICS |&gt;\n  filter(titleType == \"movie\") |&gt;\n  summarise(count = n())\n\nTITLE_tvseries &lt;- TITLE_BASICS |&gt;\n  filter(titleType == \"tvSeries\") |&gt;\n  summarise(count = n())\n\nTITLE_tvepisode &lt;- TITLE_BASICS |&gt;\n  filter(titleType == \"tvEpisode\") |&gt;\n  summarise(count = n())\n\n# Print the result\nprint(TITLE_movie)\n\n   count\n1 131662\n\nprint(TITLE_tvseries)\n\n  count\n1 29789\n\nprint(TITLE_tvepisode)\n\n   count\n1 155722\n\n\nFrom the filtered datasets, there are 132,220 movies, 29,986 TV series, and 156,725 TV episodes.\n\n\n\n\n# Load necessary libraries\nlibrary(dplyr)\n\n# Filter for living people (i.e., no deathYear) and select the oldest one by birth year\noldest_living_p &lt;- NAME_BASICS |&gt;\n  filter(is.na(deathYear) & !is.na(birthYear)) |&gt;  # Only living people with known birthYear\n  arrange(birthYear) |&gt;                             # Sort by birth year (ascending)\n  slice(1)                                           # Select the first (oldest) person\n\n# Print the result\nprint(oldest_living_p |&gt; select(primaryName, birthYear ))\n\n      primaryName birthYear\n1 Robert De Visée      1655\n\n\nThe oldest living person is Traudl Lessing, based on the data table. However, I know that is most definitely not true because she was born in 1625. When I check the IMDb site of Traudl Lessing, I see that it is missing her death date. I will change show the top 20 oldest people. Someone must have entered data incorrectly. This really shows the importance of inputting data.\n\n# Load necessary libraries\nlibrary(dplyr)\n\n# Filter for living people (i.e., no deathYear) and select the oldest one by birth year\noldest_living_p &lt;- NAME_BASICS |&gt;\n  filter(is.na(deathYear) & !is.na(birthYear)) |&gt;  # Only living people with known birthYear\n  arrange(birthYear) |&gt;                             # Sort by birth year (ascending)\n  head(20)                                         # Select the top 3 (oldest) person\n\n# Print the result\nprint(oldest_living_p |&gt; select(primaryName, birthYear ))\n\n         primaryName birthYear\n1    Robert De Visée      1655\n2     William Sandys      1767\n3     Richard Dybeck      1811\n4     Albert Monnier      1815\n5         C. Hostrup      1818\n6     Edouard Martin      1825\n7      Ion Ivanovici      1845\n8    Attilio Corbell      1850\n9      André Sylvane      1850\n10    Charles Dungan      1853\n11      Jacob Abrams      1854\n12   James W. Castle      1854\n13   Edmond Duquesne      1854\n14 Maurice Ordonneau      1854\n15      Adolf Weisse      1855\n16   Black Dyke Band      1855\n17     William Parry      1856\n18 Arthur Weinschenk      1856\n19    Emile La Croix      1857\n20    Robert Charvay      1858\n\n\nUnfortunately, the top 20 “oldest living” people based on the dataset of NAME_BASICS are all incorrect. To answer the question simply based on the data, it would be Traudl Lessing but I would need the deathYear inputted to all celebrities in order to answer the question.\n\n\n\n\nlibrary(dplyr)\n\n# Filter the ratings dataset for titles with a perfect 10/10 rating and at least 200,000 votes\nperfect_episodes &lt;- TITLE_RATINGS |&gt;\n  filter(averageRating == 10, numVotes &gt;= 200000)\n\n# Join with the basics data to get more information about TV episodes\nperfect_tv_episode &lt;- perfect_episodes |&gt;\n  inner_join(TITLE_BASICS, by = \"tconst\") |&gt;\n  filter(titleType == \"tvEpisode\")\n\n# Join with the episode dataset to find the series name\nperfect_tv_episode_show &lt;- perfect_tv_episode |&gt;\n  left_join(TITLE_EPISODES, by = \"tconst\") |&gt;\n  left_join(TITLE_BASICS, by = join_by(parentTconst == tconst), suffix = c(\"_episode\", \"_series\"))\n\n# Print the episode title and its parent series title\nperfect_tv_episode_show |&gt;\n  select(primaryTitle_episode, primaryTitle_series) |&gt;\n  print()\n\n  primaryTitle_episode primaryTitle_series\n1           Ozymandias        Breaking Bad\n\n\nIt is episode Ozymandias from Breaking Bad.\n\n\n\n\n# Find Mark Hamill's entry using his name and extract his 'knownForTitles'\nmark_hamill &lt;- NAME_BASICS|&gt;\n  filter(primaryName == \"Mark Hamill\") |&gt;\n  select(nconst, knownForTitles)\n\n# Split the knownForTitles (which is a comma-separated string) into individual tconsts\nknown_titles &lt;- unlist(strsplit(mark_hamill$knownForTitles, \",\"))\n\n# Filter the title.basics data to get information about Mark Hamill's \"known for\" titles\nmark_hamill_known_for &lt;- TITLE_BASICS|&gt;\n  filter(tconst %in% known_titles) |&gt;\n  select(primaryTitle, titleType)\n\n# Print the result\nprint(mark_hamill_known_for)\n\n                                    primaryTitle titleType\n1             Star Wars: Episode IV - A New Hope     movie\n2 Star Wars: Episode V - The Empire Strikes Back     movie\n3     Star Wars: Episode VI - Return of the Jedi     movie\n4        Star Wars: Episode VIII - The Last Jedi     movie\n\n\nMark Hamill is most known for his roles in Star Wars!\n\n\n\n\n# Filter for TV episodes and join with episode details (parentTconst)\ntv_episodes &lt;- TITLE_EPISODES|&gt;\n  inner_join(TITLE_BASICS, by = c(\"tconst\" = \"tconst\")) |&gt;\n  filter(titleType == \"tvEpisode\") |&gt;\n  select(tconst, parentTconst)\n\n# Count the number of episodes per series\nseries_episode_counts &lt;- tv_episodes|&gt;\n  group_by(parentTconst) |&gt;\n  summarise(episode_count = n()) |&gt;\n  filter(episode_count &gt; 12)  # Filter for series with more than 12 episodes\n\n# Calculate the average rating for each series based on episode ratings\nseries_avg_rating &lt;- tv_episodes|&gt;\n  inner_join(TITLE_RATINGS, by = \"tconst\") |&gt;\n  inner_join(series_episode_counts, by = \"parentTconst\") |&gt;\n  group_by(parentTconst) |&gt;\n  summarise(average_series_rating = mean(averageRating, na.rm = TRUE))|&gt;\n  arrange(desc(average_series_rating))  # Sort by highest average rating\n\n# Join with the basics dataset to get series titles\ntop_rated_series &lt;- series_avg_rating|&gt;\n  inner_join(TITLE_BASICS, by = c(\"parentTconst\" = \"tconst\")) |&gt;\n  select(primaryTitle, average_series_rating) |&gt;\n  slice(1)  # Get the series with the highest average rating\n\n# Print the result\nprint(top_rated_series)\n\n# A tibble: 1 × 2\n  primaryTitle                 average_series_rating\n  &lt;chr&gt;                                        &lt;dbl&gt;\n1 Kavya - Ek Jazbaa, Ek Junoon                  9.75\n\n\nThe Kayva TV series has the highest average rating of 9.75.\n\n\n\n\nlibrary(dplyr)\n\n# Find the tconst for Happy Days\nhappy_days_series &lt;- TITLE_BASICS |&gt;\n  filter(primaryTitle == \"Happy Days\" & titleType == \"tvSeries\") |&gt;\n  select(tconst)\n\n# Filter for Happy Days episodes from title_episode\nhappy_days_episodes &lt;- TITLE_EPISODES |&gt;\n  filter(parentTconst == happy_days_series$tconst)  |&gt;\n  select(tconst, seasonNumber, episodeNumber)\n\nI have selected the columns I am looking at. I will put it into a visualization to answer the questions.\n\nlibrary(ggplot2)\n\n# Join with ratings data to get episode ratings\nhappy_days_ratings &lt;- happy_days_episodes |&gt;\n  inner_join(TITLE_RATINGS, by = \"tconst\")  |&gt;\n  filter(!is.na(seasonNumber))  # Exclude episodes without season information\n\n# Define early seasons (1-5) and later seasons (6 and beyond)\nhappy_days_ratings &lt;- happy_days_ratings |&gt;\n  mutate(season_group = ifelse(seasonNumber &lt;= 5, \"Early Seasons (1-5)\", \"Later Seasons (6+)\"))\n\n# Calculate the average rating for early and later seasons\nseason_group_avg &lt;- happy_days_ratings |&gt;\n  group_by(season_group) |&gt;\n  summarise(average_rating = mean(averageRating, na.rm = TRUE),\n            episode_count = n())\n\n# Print the average ratings for early and later seasons\nprint(season_group_avg)\n\n# A tibble: 2 × 3\n  season_group        average_rating episode_count\n  &lt;chr&gt;                        &lt;dbl&gt;         &lt;int&gt;\n1 Early Seasons (1-5)           7.53            58\n2 Later Seasons (6+)            6.83            10\n\n# Plot average ratings of early vs later seasons\nggplot(season_group_avg, aes(x = season_group, y = average_rating, fill = season_group)) +\n  geom_bar(stat = \"identity\") +\n  labs(title = \"Average Ratings: Early vs Later Seasons of Happy Days\",\n       x = \"Season Group\",\n       y = \"Average Rating\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\nBased on the histogram, yes, it is true that the ratings of Happy Days got lower as the show progressed."
  },
  {
    "objectID": "mp02.html#quantifying-success",
    "href": "mp02.html#quantifying-success",
    "title": "Mp02",
    "section": "",
    "text": "A “success” measure that reflects both quality and popular awareness will include average ratings and number of votes. A common approach is to compute a weighted score of both of these factors so it looks like success = averageRating x log(numVotes)\n\n\n\n# Load necessary libraries\nlibrary(dplyr)\n\n# Create a success metric\nmetric &lt;- TITLE_RATINGS |&gt;\n  mutate(success_metric = averageRating * log(numVotes))\n\ntop_movies &lt;- metric |&gt;\n  arrange(desc(success_metric))  |&gt;\n  slice(1:10)  # Select the top 10 movies based on the success metric\n\n# Join with the basics dataset to get movie titles for validation\ntop_movies_with_titles &lt;- top_movies |&gt;\n  inner_join(TITLE_BASICS, by = \"tconst\")  |&gt;\n  select(primaryTitle, averageRating, numVotes, success_metric)  # Display relevant info\n\n# Print the top movies with titles and success metric\nprint(top_movies_with_titles)\n\n                                        primaryTitle averageRating numVotes\n1                                       Breaking Bad           9.5  2208030\n2                           The Shawshank Redemption           9.3  2942823\n3                                    Game of Thrones           9.2  2346428\n4                                    The Dark Knight           9.0  2922922\n5                                      The Godfather           9.2  2051186\n6      The Lord of the Rings: The Return of the King           9.0  2013824\n7                                       Pulp Fiction           8.9  2260017\n8                                          Inception           8.8  2595555\n9  The Lord of the Rings: The Fellowship of the Ring           8.9  2043202\n10                                        Fight Club           8.8  2374722\n   success_metric\n1        138.7723\n2        138.5224\n3        134.9493\n4        133.9928\n5        133.7121\n6        130.6399\n7        130.2149\n8        129.9699\n9        129.3173\n10       129.1874\n\n\n\n\n\n\n# Load necessary libraries\nlibrary(dplyr)\n\n# Create the success metric as before\nmetric &lt;- TITLE_RATINGS |&gt;\n  mutate(success_metric = averageRating * log(numVotes + 1))  # Add 1 to avoid log(0)\n\n# Filter for movies with large numbers of votes and low success metric. Assuming 'large' is more than 100,000 votes\nlow_success_movies &lt;- metric |&gt;\n  filter(numVotes &gt; 100000)  |&gt;\n  arrange(success_metric)  |&gt;\n  slice(1:5)  # Select the bottom 5 movies with poor success metric\n\n# Join with title.basics to get the titles for validation\nlow_success_movies_with_titles &lt;- low_success_movies %&gt;%\n  inner_join(TITLE_BASICS, by = \"tconst\") %&gt;%\n  select(primaryTitle, averageRating, numVotes, success_metric)  # Display relevant info\n\n# Print the bottom 5 movies with titles and metrics\nprint(low_success_movies_with_titles)\n\n       primaryTitle averageRating numVotes success_metric\n1             Radhe           1.9   180205       22.99353\n2        Epic Movie           2.4   110222       27.86463\n3         Adipurush           2.7   133981       31.87474\n4 Meet the Spartans           2.8   112199       32.55851\n5          365 Days           3.3   100579       38.01174\n\n\n\n\n\nTHe last movie I went to see in theaters was CHristopher Nolan’s Oppenheimer. I will pick him as a prestige director for this example.\n\n# Load necessary libraries\nlibrary(dplyr)\n\n# Find the nconst for Christopher Nolan\nnolan &lt;- NAME_BASICS %&gt;%\n  filter(primaryName == \"Christopher Nolan\") %&gt;%\n  select(nconst)\n\n# Find all projects where Christopher Nolan is the director\nnolan_projects &lt;- TITLE_PRINCIPALS %&gt;%\n  filter(nconst == nolan$nconst, category == \"director\") %&gt;%\n  select(tconst)\n\nI found Christopher Nolan within the Name table and Principals title. Now I will join them the success metric in the ratings table then join with title_basic to get project titles.\n\n# Join Nolan's projects with the ratings data to calculate success metrics\nnolan_projects_ratings &lt;- nolan_projects %&gt;%\n  inner_join(TITLE_RATINGS, by = \"tconst\") %&gt;%\n  mutate(success_metric = averageRating * log(numVotes + 1))  # Success metric\n\n# Step 4: Join with the basics dataset to get project titles\nnolan_projects_with_titles &lt;- nolan_projects_ratings %&gt;%\n  inner_join(TITLE_BASICS, by = \"tconst\") %&gt;%\n  select(primaryTitle, averageRating, numVotes, success_metric) %&gt;%\n  arrange(desc(success_metric))  # Sort by highest success metric\n\n# Step 5: Print top projects by success metric for Christopher Nolan\nprint(nolan_projects_with_titles)\n\n      primaryTitle averageRating numVotes success_metric\n1  The Dark Knight           9.0  2922922      133.99285\n2        Inception           8.8  2595555      129.96994\n3     Interstellar           8.7  2161548      126.90112\n4    Batman Begins           8.2  1603362      117.15843\n5      Oppenheimer           8.3   797550      112.79120\n6          Dunkirk           7.8   752538      105.54342\n7            Tenet           7.3   606902       97.20771\n8         Insomnia           7.2   323258       91.34071\n9        Following           7.4   103363       85.44049\n10            Quay           6.4     1740       47.75818\n\n\n\n\n\nOne more “spot check” can be to see if Oscar-winning movies have a high success score. I looked up some movies to manually input into the code to check.\n\n# Load necessary libraries\nlibrary(dplyr)\n\n# List of famous Oscar-winning movies (Best Picture winners)\noscar_winners &lt;- c(\"The Godfather\", \"Schindler's List\", \"The Silence of the Lambs\", \n                   \"Forrest Gump\", \"Gladiator\", \"No Country for Old Men\", \"Parasite\")\n\n# Filter the IMDb basics dataset to find tconsts of these movies\noscar_winner_movies &lt;- TITLE_BASICS %&gt;%\n  filter(primaryTitle %in% oscar_winners) %&gt;%\n  select(tconst, primaryTitle)\n\n# Step 3: Join with the ratings data to get the success metric for these movies\noscar_winner_ratings &lt;- oscar_winner_movies %&gt;%\n  inner_join(TITLE_RATINGS, by = \"tconst\") %&gt;%\n  mutate(success_metric = averageRating * log(numVotes + 1))  # Success metric\n\n# Step 4: Display the results to validate if these Oscar-winning movies score highly\noscar_winner_ratings %&gt;%\n  select(primaryTitle, averageRating, numVotes, success_metric) %&gt;%\n  arrange(desc(success_metric)) %&gt;%\n  print()\n\n               primaryTitle averageRating numVotes success_metric\n1             The Godfather           9.2  2051186      133.71215\n2              Forrest Gump           8.8  2301630      128.91233\n3          Schindler's List           9.0  1475891      127.84296\n4  The Silence of the Lambs           8.6  1578087      122.73683\n5                 Gladiator           8.5  1658228      121.73072\n6                  Parasite           8.5   993790      117.37890\n7    No Country for Old Men           8.2  1082550      113.93761\n8             The Godfather           8.3     4072       68.99072\n9                 Gladiator           6.5    10651       60.27777\n10                 Parasite           7.4     1869       55.74933\n11            The Godfather           8.3      679       54.13337\n12             Forrest Gump           7.8      540       49.08867\n13                 Parasite           8.5      298       48.45377\n14                Gladiator           7.8      323       45.08980\n15                Gladiator           7.1      449       43.37566\n16            The Godfather           8.8      106       41.12089\n17            The Godfather           7.9      127       38.33104\n18                 Parasite           5.0     1543       36.71066\n19            The Godfather           7.7      100       35.53643\n20             Forrest Gump           7.6      100       35.07492\n21   No Country for Old Men           7.2      101       33.29980\n22                 Parasite           4.1     3143       33.01833\n23            The Godfather           6.5      145       32.39344\n24            The Godfather           5.3      444       32.31979\n25            The Godfather           5.9      216       31.74139\n26                 Parasite           4.9      399       29.35818\n27                 Parasite           2.8      698       18.33902"
  }
]
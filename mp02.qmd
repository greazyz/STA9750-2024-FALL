---
title: "Mp02"
author: "Gracie Zheng"
editor: visual
---

# The Business of Show Business

As a Hollywood development director, I am always looking into the next **BIG** thing. To make the biggest movie of 2025 and be invited to Cannes Film Festival, I will dive into the data of movies to find the perfect opportunity.

## Datasets for Research

Credits to IMDb, with their expansive library of movies, I will use their datasets for my research. The code to extract the data is as follows:

```{r}
get_imdb_file <- function(fname){
    BASE_URL <- "https://datasets.imdbws.com/"
    fname_ext <- paste0(fname, ".tsv.gz")
    if(!file.exists(fname_ext)){
        FILE_URL <- paste0(BASE_URL, fname_ext)
        download.file(FILE_URL, 
                      destfile = fname_ext)
    }
    as.data.frame(readr::read_tsv(fname_ext, lazy=FALSE))
}

NAME_BASICS      <- get_imdb_file("name.basics")
TITLE_BASICS     <- get_imdb_file("title.basics")
TITLE_EPISODES   <- get_imdb_file("title.episode")
TITLE_RATINGS    <- get_imdb_file("title.ratings")
TITLE_CREW       <- get_imdb_file("title.crew")
TITLE_PRINCIPALS <- get_imdb_file("title.principals")
```

## Data Sub-Sampling

With such a huge dataset, I narrow down to people with at least 2 "known for" credits.

```{r}
# make sure to run this
library(stringr)
NAME_BASICS <- NAME_BASICS |> 
    filter(str_count(knownForTitles, ",") > 1)
```

Then I narrow down titles through rating count. Pictured below is a visualization of the distribution of rating counts across the titles:

```{r}
#make sure to
install.packages("ggplot2")
#load 
library(ggplot2)

TITLE_RATINGS |>
    ggplot(aes(x=numVotes)) + 
    geom_histogram(bins=30) +
    xlab("Number of IMDB Ratings") + 
    ylab("Number of Titles") + 
    ggtitle("Majority of IMDB Titles Have Less than 100 Ratings") + 
    theme_bw() + 
    scale_x_log10(label = scales::comma) + 
    scale_y_continuous(label = scales::comma)

print(ggplot)
```

About 75% of the dataset is has less than 100 ratings and we can see this through quantile distribution:

```{r}
#load library(dplyr) for function "pull"
library(dplyr)
TITLE_RATINGS |>
    pull(numVotes) |>
    quantile()
```

Through this step, I filter the data to only view titles with 100 or more ratings:

```{r}
TITLE_RATINGS <- TITLE_RATINGS |>
    filter(numVotes >= 100)
```

This filtering is then applied to the rest of the data tables:

```{r}
TITLE_BASICS <- TITLE_BASICS |>
    semi_join(TITLE_RATINGS, 
              join_by(tconst == tconst))

TITLE_CREW <- TITLE_CREW |>
    semi_join(TITLE_RATINGS, 
              join_by(tconst == tconst))

TITLE_EPISODES_1 <- TITLE_EPISODES |>
    semi_join(TITLE_RATINGS, 
              join_by(tconst == tconst))
TITLE_EPISODES_2 <- TITLE_EPISODES |>
    semi_join(TITLE_RATINGS, 
              join_by(parentTconst == tconst))

TITLE_EPISODES <- bind_rows(TITLE_EPISODES_1,
                            TITLE_EPISODES_2) |>
    distinct()

TITLE_PRINCIPALS <- TITLE_PRINCIPALS |>
    semi_join(TITLE_RATINGS, join_by(tconst == tconst))


rm(TITLE_EPISODES_1)
rm(TITLE_EPISODES_2)
```

From the IMDb site, I see that columns that should be set as numeric type are set as character (string) vectors. I change this by using the following command:

```{r}
# Load dplyr library
library(dplyr)

NAME_BASICS <- NAME_BASICS |>
    mutate(birthYear = as.numeric(birthYear),
           deathYear = as.numeric(deathYear))
```

### Task 1

In Task 1, I will correct the column types of applicable tables, just like with the NAME_BASICS table.

```{r}
TITLE_BASICS <- TITLE_BASICS |>
  mutate(
    isAdult = as.logical(isAdult),
    startYear = as.numeric(startYear),    # Coerce
    endYear = as.numeric(endYear), # Coerce 
    runtimeMinutes = as.numeric(runtimeMinutes)
  )

TITLE_EPISODES <- TITLE_EPISODES |>
  mutate(seasonNumber = as.numeric(seasonNumber),
         episodeNumber = as.numeric(episodeNumber))

TITLE_RATINGS <- TITLE_RATINGS |>
  mutate(
    averageRating = as.numeric(averageRating),    # Coerce
    numVotes = as.numeric(numVotes )     # Coerce 
  )
```

Looking through the IMDb dataset details on the site, I found that only TITLE_BASICS and TITLE_RATINGS needed to be corrected.

### Task 2

Using dplyr functionality, I will answer these questions:

#### How many movies are in our data set? How many TV series? How many TV episodes?

```{r}
# Load necessary libraries
library(dplyr)

# Count the number
TITLE_movie <- TITLE_BASICS |>
  filter(titleType == "movie") |>
  summarise(count = n())

TITLE_tvseries <- TITLE_BASICS |>
  filter(titleType == "tvSeries") |>
  summarise(count = n())

TITLE_tvepisode <- TITLE_BASICS |>
  filter(titleType == "tvEpisode") |>
  summarise(count = n())

# Print the result
print(TITLE_movie)
print(TITLE_tvseries)
print(TITLE_tvepisode)
```

*From the filtered datasets, there are 132,220 movies, 29,986 TV series, and 156,725 TV episodes.*

#### Who is the oldest living person in our data set?

```{r}
# Load necessary libraries
library(dplyr)

# Filter for living people (i.e., no deathYear) and select the oldest one by birth year
oldest_living_p <- NAME_BASICS |>
  filter(is.na(deathYear) & !is.na(birthYear)) |>  # Only living people with known birthYear
  arrange(birthYear) |>                             # Sort by birth year (ascending)
  slice(1)                                           # Select the first (oldest) person

# Print the result
print(oldest_living_p |> select(primaryName, birthYear ))
```

*The oldest living person is Traudl Lessing, based on the data table. However, I know that is most definitely not true because she was born in 1625. When I check the [IMDb site](https://www.imdb.com/name/nm3545517/) of Traudl Lessing, I see that it is missing her death date. I will change show the top 20 oldest people. Someone must have entered data incorrectly. This really shows the importance of inputting data.*

```{r}
# Load necessary libraries
library(dplyr)

# Filter for living people (i.e., no deathYear) and select the oldest one by birth year
oldest_living_p <- NAME_BASICS |>
  filter(is.na(deathYear) & !is.na(birthYear)) |>  # Only living people with known birthYear
  arrange(birthYear) |>                             # Sort by birth year (ascending)
  head(20)                                         # Select the top 3 (oldest) person

# Print the result
print(oldest_living_p |> select(primaryName, birthYear ))
```

*Unfortunately, the top 20 "oldest living" people based on the dataset of NAME_BASICS are all incorrect. To answer the question simply based on the data, it would be Traudl Lessing but I would need the deathYear inputted to all celebrities in order to answer the question.*

#### There is one TV Episode in this data set with a perfect 10/10 rating and at least 200,000 IMDb ratings. What is it? What series does it belong to?

```{r}
library(dplyr)

# Filter the ratings dataset for titles with a perfect 10/10 rating and at least 200,000 votes
perfect_episodes <- TITLE_RATINGS |>
  filter(averageRating == 10, numVotes >= 200000)

# Join with the basics data to get more information about TV episodes
perfect_tv_episode <- perfect_episodes |>
  inner_join(TITLE_BASICS, by = "tconst") |>
  filter(titleType == "tvEpisode")

# Join with the episode dataset to find the series name
perfect_tv_episode_show <- perfect_tv_episode |>
  left_join(TITLE_EPISODES, by = "tconst") |>
  left_join(TITLE_BASICS, by = join_by(parentTconst == tconst), suffix = c("_episode", "_series"))

# Print the episode title and its parent series title
perfect_tv_episode_show |>
  select(primaryTitle_episode, primaryTitle_series) |>
  print()

```

*It is episode Ozymandias from Breaking Bad.*

#### What four projects is the actor Mark Hamill most known for?

```{r}
# Find Mark Hamill's entry using his name and extract his 'knownForTitles'
mark_hamill <- NAME_BASICS|>
  filter(primaryName == "Mark Hamill") |>
  select(nconst, knownForTitles)

# Split the knownForTitles (which is a comma-separated string) into individual tconsts
known_titles <- unlist(strsplit(mark_hamill$knownForTitles, ","))

# Filter the title.basics data to get information about Mark Hamill's "known for" titles
mark_hamill_known_for <- TITLE_BASICS|>
  filter(tconst %in% known_titles) |>
  select(primaryTitle, titleType)

# Print the result
print(mark_hamill_known_for)
```

*Mark Hamill is most known for his roles in Star Wars!*

#### What TV series, with more than 12 episodes, has the highest average rating?

```{r}

# Filter for TV episodes and join with episode details (parentTconst)
tv_episodes <- TITLE_EPISODES|>
  inner_join(TITLE_BASICS, by = c("tconst" = "tconst")) |>
  filter(titleType == "tvEpisode") |>
  select(tconst, parentTconst)

# Count the number of episodes per series
series_episode_counts <- tv_episodes|>
  group_by(parentTconst) |>
  summarise(episode_count = n()) |>
  filter(episode_count > 12)  # Filter for series with more than 12 episodes

# Calculate the average rating for each series based on episode ratings
series_avg_rating <- tv_episodes|>
  inner_join(TITLE_RATINGS, by = "tconst") |>
  inner_join(series_episode_counts, by = "parentTconst") |>
  group_by(parentTconst) |>
  summarise(average_series_rating = mean(averageRating, na.rm = TRUE))|>
  arrange(desc(average_series_rating))  # Sort by highest average rating

# Join with the basics dataset to get series titles
top_rated_series <- series_avg_rating|>
  inner_join(TITLE_BASICS, by = c("parentTconst" = "tconst")) |>
  select(primaryTitle, average_series_rating) |>
  slice(1)  # Get the series with the highest average rating

# Print the result
print(top_rated_series)
```

*The Kayva TV series has the highest average rating of 9.75.*

#### The TV series Happy Days (1974-1984) gives us the common idiom “jump the shark”. The phrase comes from a controversial fifth season episode (aired in 1977) in which a lead character literally jumped over a shark on water skis. Idiomatically, it is used to refer to the moment when a once-great show becomes ridiculous and rapidly looses quality. Is it true that episodes from later seasons of Happy Days have lower average ratings than the early seasons?

```{r, message = FALSE, warning = FALSE}
library(dplyr)

# Find the tconst for Happy Days
happy_days_series <- TITLE_BASICS |>
  filter(primaryTitle == "Happy Days" & titleType == "tvSeries") |>
  select(tconst)

# Filter for Happy Days episodes from title_episode
happy_days_episodes <- TITLE_EPISODES |>
  filter(parentTconst == happy_days_series$tconst)  |>
  select(tconst, seasonNumber, episodeNumber)
```

I have selected the columns I am looking at. I will put it into a visualization to answer the questions.


```{r}
library(ggplot2)

# Join with ratings data to get episode ratings
happy_days_ratings <- happy_days_episodes |>
  inner_join(TITLE_RATINGS, by = "tconst")  |>
  filter(!is.na(seasonNumber))  # Exclude episodes without season information

# Define early seasons (1-5) and later seasons (6 and beyond)
happy_days_ratings <- happy_days_ratings |>
  mutate(season_group = ifelse(seasonNumber <= 5, "Early Seasons (1-5)", "Later Seasons (6+)"))

# Calculate the average rating for early and later seasons
season_group_avg <- happy_days_ratings |>
  group_by(season_group) |>
  summarise(average_rating = mean(averageRating, na.rm = TRUE),
            episode_count = n())

# Print the average ratings for early and later seasons
print(season_group_avg)

# Plot average ratings of early vs later seasons
ggplot(season_group_avg, aes(x = season_group, y = average_rating, fill = season_group)) +
  geom_bar(stat = "identity") +
  labs(title = "Average Ratings: Early vs Later Seasons of Happy Days",
       x = "Season Group",
       y = "Average Rating") +
  theme_minimal()
```

*Based on the histogram, yes, it is true that the ratings of Happy Days got lower as the show progressed.*

## Quantifying Success

A "success" measure that reflects both quality and popular awareness will include average ratings and number of votes. A common approach is to compute a weighted score of both of these factors so it looks like `success = averageRating x log(numVotes)`

#### Choose the top 5-10 movies on your metric and confirm that they were indeed box office successes.

```{r}

# Load necessary libraries
library(dplyr)

# Create a success metric
metric <- TITLE_RATINGS |>
  mutate(success_metric = averageRating * log(numVotes))

top_movies <- metric |>
  arrange(desc(success_metric))  |>
  slice(1:10)  # Select the top 10 movies based on the success metric

# Join with the basics dataset to get movie titles for validation
top_movies_with_titles <- top_movies |>
  inner_join(TITLE_BASICS, by = "tconst")  |>
  select(primaryTitle, averageRating, numVotes, success_metric)  # Display relevant info

# Print the top movies with titles and success metric
print(top_movies_with_titles)
```

#### Choose 3-5 movies with large numbers of IMDb votes that score poorly on your success metric and confirm that they are indeed of low quality.

```{r}
# Load necessary libraries
library(dplyr)

# Create the success metric as before
metric <- TITLE_RATINGS |>
  mutate(success_metric = averageRating * log(numVotes + 1))  # Add 1 to avoid log(0)

# Filter for movies with large numbers of votes and low success metric. Assuming 'large' is more than 100,000 votes
low_success_movies <- metric |>
  filter(numVotes > 100000)  |>
  arrange(success_metric)  |>
  slice(1:5)  # Select the bottom 5 movies with poor success metric

# Join with title.basics to get the titles for validation
low_success_movies_with_titles <- low_success_movies %>%
  inner_join(TITLE_BASICS, by = "tconst") %>%
  select(primaryTitle, averageRating, numVotes, success_metric)  # Display relevant info

# Print the bottom 5 movies with titles and metrics
print(low_success_movies_with_titles)
```

#### Choose a prestige actor or director and confirm that they have many projects with high scores on your success metric.

THe last movie I went to see in theaters was CHristopher Nolan's *Oppenheimer*. I will pick him as a prestige director for this example. 

```{r, message = FALSE, warning = FALSE}

# Load necessary libraries
library(dplyr)

# Find the nconst for Christopher Nolan
nolan <- NAME_BASICS %>%
  filter(primaryName == "Christopher Nolan") %>%
  select(nconst)

# Find all projects where Christopher Nolan is the director
nolan_projects <- TITLE_PRINCIPALS %>%
  filter(nconst == nolan$nconst, category == "director") %>%
  select(tconst)
```

I found Christopher Nolan within the Name table and Principals title. Now I will join them the success metric in the ratings table then join with title_basic to get project titles. 

```{r}
# Join Nolan's projects with the ratings data to calculate success metrics
nolan_projects_ratings <- nolan_projects %>%
  inner_join(imdb_ratings, by = "tconst") %>%
  mutate(success_metric = averageRating * log(numVotes + 1))  # Success metric

# Step 4: Join with the basics dataset to get project titles
nolan_projects_with_titles <- nolan_projects_ratings %>%
  inner_join(TITLE_BASICS, by = "tconst") %>%
  select(primaryTitle, averageRating, numVotes, success_metric) %>%
  arrange(desc(success_metric))  # Sort by highest success metric

# Step 5: Print top projects by success metric for Christopher Nolan
print(nolan_projects_with_titles)
```

#### Perform at least one other form of ‘spot check’ validation.

One more "spot check" can be to see if Oscar-winning movies have a high success score.
I looked up some movies to manually input into the code to check. 

```{r}
# Load necessary libraries
library(dplyr)
library(readr)

# Read IMDb datasets
imdb_basics <- read_tsv("path_to_your_file/title.basics.tsv.gz", na = "\\N")
imdb_ratings <- read_tsv("path_to_your_file/title.ratings.tsv.gz", na = "\\N")

# Step 1: List of famous Oscar-winning movies (Best Picture winners)
oscar_winners <- c("The Godfather", "Schindler's List", "The Silence of the Lambs", 
                   "Forrest Gump", "Gladiator", "No Country for Old Men", "Parasite")

# Step 2: Filter the IMDb basics dataset to find tconsts of these movies
oscar_winner_movies <- imdb_basics %>%
  filter(primaryTitle %in% oscar_winners) %>%
  select(tconst, primaryTitle)

# Step 3: Join with the ratings data to get the success metric for these movies
oscar_winner_ratings <- oscar_winner_movies %>%
  inner_join(imdb_ratings, by = "tconst") %>%
  mutate(success_metric = averageRating * log(numVotes + 1))  # Success metric

# Step 4: Display the results to validate if these Oscar-winning movies score highly
oscar_winner_ratings %>%
  select(primaryTitle, averageRating, numVotes, success_metric) %>%
  arrange(desc(success_metric)) %>%
  print()
```







